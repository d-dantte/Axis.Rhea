#
# Defines an XPath-like language for querying ion values.
# Samples
# 1. cannonical form: /prop{other stuff}/annot{stuff} index{< 7 | = 5}/value{bleh.+}
# 2. shortened form:  /.{other stuff}/@{stuff} #{< 7 | = 20}/${bleh.+}
# Both essentially say given a struct:
# 1. Find a property with name "other stuff"
# 2. The property found is expected to yield a ion-list, having an annotation equal to "stuff". Get all items at indexs < 7, or equal 20
# 3. All items found at the given indexes are expected to yield ion-strings/ion-identifiers/ion-quotedsymbols, and their values must match the given regex (bleh.+)
# 
# /${# .count.tostring.count.tostring.count = 6}

# Query
$query -> $predicate-node.+

# Predicate Node
$predicate-node -> +[$ml-space.? "/" $line-space.? ?[
	$property-name
 	$list-index
	$conditionals]]

$property-name -> /^[a-zA-Z]\w*$/.1,
$list-index -> +["[" $line-space.? $integer $line-space.? "]"]

$conditionals -> +[$annotation-conditional.? $line-space.? ?[
	$property-conditional
	$list-conditional
	$value-conditional]]


# Annotation Conditional
$annotation-conditional -> +[?[$annotation-delimiter-name $annotation-delimiter-symbol] $regex-predicate]
$annotation-delimiter-name -> "annot"
$annotation-delimiter-symbol -> "@"


# Property Conditional
$property-conditional -> +[?[$property-delimiter-name $property-delimiter-symbol] $relational-predicate]
$property-delimiter-name -> "prop"
$property-delimiter-symbol -> "."


# List Conditional - has access to the $, and # variables
$list-conditional -> +[?[$list-delimiter-name $list-delimiter-symbol] $relational-predicate]
$list-delimiter-name -> "list"
$list-delimiter-symbol -> "#"


# Value Conditional - has access to the $ variable
$value-conditional -> +[?[$value-delimiter-name $value-delimiter-symbol] $relational-predicate]
$value-delimiter-name -> "value"
$value-delimiter-symbol -> "$"


# Regex Predicate
$regex-predicate -> @regex-string


# Relational Predicate
$relational-predicate -> +["{" $line-space.? $logical-expression $line-space.? "}"]


# Expression
$expression -> ?[+["(" $line-space.? $exp-group-tail] $exp]
$exp-group-tail -> +[$logical-expression $line-space.? ")"]
$exp -> $logical-expression


# Logical Expression
$logical-expression -> +[$logical-xor-expression +[$line-space $logical-or-operator $line-space $expression].?]
$logical-xor-expression -> +[$logical-nor-expression +[$line-space $logical-xor-operator $line-space $expression].?]
$logical-nor-expression -> +[$logical-and-expression +[$line-space $logical-nor-operator $line-space $expression].?]
$logical-and-expression -> +[$relational-expression +[$line-space $logical-and-operator $line-space $expression].?]
$logical-or-operator -> "||"
$logical-xor-operator -> "^^"
$logical-nor-operator -> "~~"
$logical-and-operator -> "&&"


# Relational Expression
$relational-expression -> +[$arithmetic-expression +[$line-space $relational-operator $line-space $relational-rhs].?]
$relational-rhs -> ?[$type-expression $list-expression $range-expression $expression]
$range-expression -> +[$expression ".." $expression]
$list-expression -> +["(" $line-space.? $expression +[$line-space.? "," $line-space $expression].* $line-space.? ")"]
$type-expression -> ?[
	"Bool" "Int" "Float" "Decimal" "Timestamp"
	"String" "Identifier" "Operator" "QuotedSymbol"
	"Clob" "Blob"
	"Sexp" "List"
	"Struct"
	"Null"]
$relational-operator -> ?[
	"is not" "is"
	 "!=" "="
	 "<=" ">=" "<" ">"
	 "not in" "in"
	 "not between" "between"
	 "starts with" "ends with"
	 "matches"]


# Arithmetic Expression
$arithmetic-expression -> +[$multiplicative-expression +[$line-space ?["+" "-"] $line-space $expression].?]
$multiplicative-expression -> +[$transformation-expression +[$line-space ?["*" "/" "%"] $line-space $expression].?]


# Transformation Expression
$transformation-expression -> +[?[$variable-expression $constant-expression $expression] +[$line-space.? "." $transformation].*]
$transformation -> ?[
	"to-lower" "to-upper"
	"reverse"
	"negation" "count"
	"is-null" "is-not-null"]


# Variable Expression
$variable-expression -> ?["$" "#"]


# Constant Expression
$constant-expression -> ?[
	$timestamp-constant
	$string-constant
	$boolean-constant
	$numeric-constant]

$boolean-constant -> ?["true" "false"]

$numeric-constant -> +[$negative.? $integer $fraction.?]
$integer -> /^\d+$/
$fraction -> /^\.\d+$/.2,+
$negative -> "-"

$string-constant -> @singleline-string

$timestamp-constant -> ?[$now $timespan $date-time]
$now -> "now"
# $timespan -> /^(\d+)|((\d+\.)?[0-5]?\d(:[0-5]?\d(:[0-5]\d(\.\d{1,7})?)?)?)$/
$timespan -> ?[
	$days-hours-minutes-seconds-ticks-segment
	$hours-minutes-seconds-ticks-segment
	$days-hours-minutes-seconds-segment
	$hours-minutes-seconds-segment
	$days-hours-minutes-segment
	$hours-minutes-segment]
$days-hours-minutes-segment -> /^\d+\.[0-5]?\d:[0-5]?\d$/.5,7
$days-hours-minutes-seconds-segment -> /^\d+\.[0-5]?\d:[0-5]?\d:[0-5]?\d$/.7,10
$days-hours-minutes-seconds-ticks-segment -> /^\d+\.[0-5]?\d:[0-5]?\d:[0-5]?\d\.\d{1,7}$/.9,18
$hours-minutes-segment -> /^[0-5]?\d:[0-5]?\d$/.3,5
$hours-minutes-seconds-segment -> /^[0-5]?\d:[0-5]?\d:[0-5]?\d$/.5,8
$hours-minutes-seconds-ticks-segment -> /^[0-5]?\d:[0-5]?\d:[0-5]?\d\.\d{1,7}$/.7,16
$date-time -> /^\d{4}\-\d{2}-\d{2}( [0-5]?\d:[0-5]?\d(:[0-5]?\d(\.\d{1,7})?)?)?$/.10,27

# Misc
$line-space -> $whitespace.+
$ml-space -> ?[$whitespace $new-line $carriage-return].+
$whitespace -> ?[$space $tab]
$space -> ' '
$tab -> '\t'
$new-line -> '\n'
$carriage-return -> '\r'
